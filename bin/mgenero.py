#!/usr/bin/env python
import sys, os, argparse, shutil, traceback, yaml

from dave.mgenero.mgenero import ModelCreator
from configobj import ConfigObj


#Create a standard command line parser
parser = argparse.ArgumentParser(description="Stamp analog model from template")
parser.add_argument('template_name', metavar='Template', help='Template used to generate model')
parser.add_argument('circuit_name', metavar='Spice File/User Provided Name')
parser.add_argument('-f', '--functional', dest='functional', action='store', help='Generates a functional model from user provided circuit template parameters. Use: --functional parameters.yaml')
parser.add_argument('-c', '--create', dest='create', action='store', help='Create default circuit, sim, user config files')

#Read in the command line arguments
args = parser.parse_args()

if args.functional or args.create:
	dut = args.circuit_name
else:
	with open('%s.cfg' % args.circuit_name, 'r') as cfg:
		circuit_cfg = yaml.load(cfg)
		dut = circuit_cfg['module_name']
		#line = cfg.readline()
		#tokens = line.strip().split() 
		#dut = tokens[1]

generic_module_name = args.template_name

#These are files that the user most provide
mdl_template  = os.path.join(os.environ['DAVE_SAMPLES'],'mGenero/template/{0}/{1}'.format(generic_module_name,'%s.template.sv' % generic_module_name)) # model template
test_template = os.path.join(os.environ['DAVE_SAMPLES'],'mGenero/template/{0}/{1}'.format(generic_module_name,'%s.test.template.cfg' % generic_module_name)) # test template
ifc_f         = os.path.join(os.environ['DAVE_SAMPLES'],'mGenero/template/{0}/{0}.ifc.yaml'.format(generic_module_name)) # interface template
sim_f         = './.collateral/sim.cfg'

if not os.path.exists('./.collateral'):
	os.mkdir('.collateral')

if not os.path.exists(sim_f):	
	sim_template_f = os.path.join(os.environ['DAVE_SAMPLES'],'mGenero/settings/sim.template.cfg')

	stf = ConfigObj(sim_template_f)
	stf['DEFAULT']['dut']         = dut
	stf['DEFAULT']['prj_dir']     = os.getcwd() # add current directory
	stf['golden']['circuit'][dut] = '%(ckt_dir)s/%(dut)s.sp'
	
	with open(sim_f, 'w') as stf_out:
		stf.write(stf_out)
		
	
cfg_f          = "%s.cfg" % dut # user configuration of interface template
user_test_file = 'user.cfg'

#Make sure that all of these files exist before continuing!
file_list  = [mdl_template, test_template, ifc_f, sim_f, cfg_f, user_test_file]
path_check = [os.path.exists(filename) for filename in file_list]
if not reduce(lambda x, y: x & y, path_check):
	for valid, path in zip(path_check, file_list):
		if not valid:
			print('\033[1;31mError\033[0m: File {} does not exist'.format(path))
	exit()
	
#Files that will be generated by mGenero / mProbo
mdl_i_dst_file = './.collateral/%s.intermediate.v' % dut  # intermediate verilog model (before back-annotation)
mdl_dst_file   = '%s.v' % dut  # verilog model 
test_dst_file  = 'test.cfg'


if args.create:
	shutil.copy2(ifc_f, os.path.join(os.getcwd(), '%s.cfg' % dut))
	shutil.copy2(test_template, os.path.join(os.getcwd(), '_test.cfg'))
	exit()

if args.functional:
	# Instantiation of Model generator class
	m = ModelCreator(cfg_f, ifc_f)
	# Generate a model from a template
	m.generate_model(mdl_template, mdl_i_dst_file) 
	# Back-annotate given model parameters to the generated model
	m.backannotate_model(mdl_i_dst_file, mdl_dst_file, os.path.join('./', args.functional))
	exit()
else:
	# Instantiation of Model generator class
	m = ModelCreator(cfg_f, ifc_f) 
	# Generate a model from a template
	m.generate_model(mdl_template, mdl_i_dst_file) 
	# Model parameter calibration
	m.generate_test(test_template, test_dst_file, user_test_file) # Generate the corresponding test from a template
	m.run_characterization(no_processes=4, test_cfg='test.cfg', sim_cfg=sim_f) # Run circuit characterization using mProbo
	# Back-annotate model parameters to the generated model
	m.backannotate_model(mdl_i_dst_file, mdl_dst_file, './.mProbo/extracted_linear_model.yaml')
	# Run equivalence checking using mProbo
	m.run_equivalence(no_processes=4, test_cfg='test.cfg', sim_cfg=sim_f)
	exit()
